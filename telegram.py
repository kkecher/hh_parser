#!/usr/bin/env python3.6

"""
Get vacancies from db, filter them, format and send to Telegram.

Telegram bot API:
https://core.telegram.org/bots
https://core.telegram.org/bots/api
"""

from copy import deepcopy
from pathlib import Path
import datetime
import os
import re
import sqlite3
import time

import requests

from config import import_database_columns
from shared import set_is_sent_1
import tests.input_tests as in_tests
import tests.output_tests as out_tests

def format_inverse_query(query):
    """
    Format autogenerated inverse queries to valid ones.
    """
    in_tests.test_var_type(query, "query", str)
    in_tests.test_var_len_more_than(query, "query", 0)
    # Line order matters!
    query = query.replace ("== NOT", "!=")
    query = query.replace ("<> NOT", "==")
    query = query.replace (">= NOT", "<")
    query = query.replace ("<= NOT", ">")
    query = query.replace ("!= NOT", "==")
    query = query.replace ("= NOT", "!=")
    query = query.replace ("> NOT", "<=")
    query = query.replace ("< NOT", ">=")
    query = query.replace ("NOT BETWEEN NOT", "BETWEEN")
    query = query.replace ("BETWEEN NOT", "NOT BETWEEN")
    query = query.replace ("NOT IN NOT", "IN")
    query = query.replace ("IN NOT", "NOT IN")
    query = query.replace ("IS NOT NULL NOT", "IS NULL")
    query = query.replace ("IS NULL NOT", "IS NOT NULL")
    query = query.replace ("NOT LIKE NOT", "LIKE")
    query = query.replace ("LIKE NOT", "NOT LIKE")
    query = query.replace ("NOT EXISTS NOT", "EXISTS")
    query = query.replace ("EXISTS NOT", "NOT EXISTS")
    query = query.replace ("NOT REGEXP NOT", "REGEXP")
    query = query.replace ("REGEXP NOT", "NOT REGEXP")
    query = query.replace (" NOT NOT", "")
    query = query.replace ("OR (", "OR ")
    out_tests.test_var_type(query, "query", str)
    out_tests.test_var_len_more_than(query, "query", 0)
    return (query)

def sanitize_filters_first_keys(user_first_keys):
    """
    Check if first two keys are in a
    ["{areas_table}.id", "{vacancies_table}.is_sent"]
    """
    valid_first_keys = ["{areas_table}.id", "{vacancies_table}.is_sent"]
    user_first_key = user_first_keys[0]
    user_second_key = user_first_keys[1]
    assert user_first_key in valid_first_keys and \
        user_second_key in valid_first_keys,\
        "\n\n'{areas_table}.id' and '{vacancies_table}.is_sent' must be \
at `filters` beginning.\n\
Got: %s and %s" % (user_first_key, user_second_key)
    return ()

def sanitize_filters_columns(key, config_tables, filters_tables):
    """
    Check if key table is in `config.yaml > tables`.
    """
    user_table_column = key.format(**config_tables)
    user_table = user_table_column.split(".")[0]
    user_column = user_table_column.split(".")[1]

    assert user_table in filters_tables,\
        "\n\nTable must be in `config.yaml > filters_tables\n\
Got table: %s" % (user_table)

    filters_columns = filters_tables[user_table]
    assert user_column in filters_columns,\
        "\n\nColumn must be in `config.yaml > filtes_columns > %s\n\
Got column: %s" % (user_table, user_column)
    out_tests.test_table_name(user_table)
    out_tests.test_table_name(user_column)
    return (user_table_column)

def sanitize_filters_operator(operator):
    """
    Check if operator is in supported operators.
    """
    white_operators = [
        "=", "==", "<>", "!=", ">", ">=", "<", "<=", \
        "IN", "BETWEEN", "IS NULL", "LIKE", "EXISTS", "REGEXP"
    ]
    in_tests.test_var_type(operator, "operator", str)
    in_tests.test_var_len_more_than(operator, "operator", 0)
    naked_operator = operator.replace("NOT", "").strip()
    assert naked_operator in white_operators, \
        "\n\nSorry, operator `%s` is not supported. Try to edit `config.yaml > \
filters`" % (operator)
    return (operator)

def sanitize_filters_pattern(pattern):
    """
    Transform pattern to string.
    """
    def create_pattern_generator(pattern):
        """
        Create pattern iterator to flatten multilevel one
        into single-level pattern list.
        """
        if isinstance(pattern, (list)):
            for p in pattern:
                yield from create_pattern_generator(p)
            if pattern == []: yield ""
        elif isinstance(pattern, str) and "," in pattern:
            yield from create_pattern_generator(pattern.split(","))
        elif isinstance(pattern, str):
            yield (pattern.strip())
        elif isinstance(pattern, (int, float)):
            yield (str(pattern))
        else:
            print (
f"\n\ntype(pattern) must be in [str, int, float, list]\n\
Try to edit pattern `{pattern}`\n\n")
            raise TypeError

    splitted_pattern = []
    for gen_pattern in create_pattern_generator(pattern):
        splitted_pattern.append(gen_pattern)
    out_tests.test_var_type(splitted_pattern, "splitted_pattern", list)
    return (splitted_pattern)

def format_filters_to_query(filters, config):
    """
    1. Format filters to sql query part.
    2. Create inverse filters query part to check filtered vacancies.
    3. Get user patterns.
    """
    areas_table = deepcopy(config["tables"]["areas_table"])
    vacancies_table = deepcopy(config["tables"]["vacancies_table"])
    config_tables = deepcopy(config["tables"])
    filters_tables = import_database_columns(config)
    in_tests.test_format_filters_to_query(filters)
    filters_query_part = ""
    inverse_filters_query_part = ""
    patterns = []
    user_first_keys = []
    for key, value in filters.items():
        if len(user_first_keys) < 2:
            user_first_keys.append(key)
        if len(user_first_keys) == 2:
            sanitize_filters_first_keys(user_first_keys)
        column = sanitize_filters_columns(key, config_tables, filters_tables)
        operator = sanitize_filters_operator(value[0])
        pattern = sanitize_filters_pattern(value[1])
        patterns += pattern
        filters_query_part += \
f"{column} {operator} ({', '.join('?' * len(pattern))}) AND "
        # We want to keep direct ‘areas_id’ and ‘is_sent’  in inverse_filters
        if column in [f"{areas_table}.id", f"{vacancies_table}.is_sent"]:
            inverse_filters_query_part += \
f"{column} {operator} ({', '.join('?' * len(pattern))}) AND "
        else:
            inverse_filters_query_part += \
f"({column} {operator} NOT ({', '.join('?' * len(pattern))}) OR "
    filters_query_part = filters_query_part[:-len(" AND ")]
    if inverse_filters_query_part.endswith(" OR "):
        inverse_filters_query_part = \
format_inverse_query(inverse_filters_query_part[:-len(" OR ")] + ")")
    if inverse_filters_query_part.endswith(" AND "):
        inverse_filters_query_part = \
format_inverse_query(inverse_filters_query_part[:-len(" AND ")])
    query_filters = [patterns, filters_query_part, inverse_filters_query_part]
    out_tests.test_format_filters_to_query(filters, query_filters)
    return (query_filters)

def regexp(expr, item):
    if item is None:
        return False
    else:
        reg = re.compile(expr)
        return reg.search(str(item)) is not None

def filter_vacancies(config, msg_columns, query_filters):
    """
    Select vacancies which contain and don't contain patterns from `filters` and
    return them as list of dicts.
    """
    database = deepcopy(config["database"])
    areas_table = deepcopy(config["tables"]["areas_table"])
    vacancies_table = deepcopy(config["tables"]["vacancies_table"])
    patterns = query_filters[0]
    filters_query_part = query_filters[1]
    inverse_filters_query_part = query_filters[2]
    in_tests.test_filter_vacancies(msg_columns)
    print ("\n\nFiltering vacancies...")

    connection = sqlite3.connect(database)
    cursor = connection.cursor()
    connection.create_function("REGEXP", 2, regexp)
    msg_columns_query = ", ".join(msg_columns)
    filters_query = f"SELECT {msg_columns_query} FROM \
{vacancies_table} LEFT JOIN {areas_table} ON {vacancies_table}.area_id == \
{areas_table}.id WHERE {filters_query_part}"
    inverse_filters_query =  f"SELECT {msg_columns_query} FROM \
{vacancies_table} LEFT JOIN {areas_table} ON {vacancies_table}.area_id == \
{areas_table}.id WHERE {inverse_filters_query_part}"
    clean_values = cursor.execute(filters_query, patterns)
    clean_vacancies = [dict(zip(msg_columns, clean_value)) for
                       clean_value in clean_values]
    dirty_values = cursor.execute(inverse_filters_query, patterns)
    dirty_vacancies = [dict(zip(msg_columns, dirty_value)) for
                       dirty_value in dirty_values]
    filtered_vacancies = [clean_vacancies, dirty_vacancies]
    cursor.close()
    connection.close()
    out_tests.test_filter_vacancies(filtered_vacancies, msg_columns)
    return (filtered_vacancies)

def replace_specials_to_underscore(string):
    """
    Replace all none alphanumeric characters to `_`.
    """
    in_tests.test_var_type(string, "string", str)

    new_string = ""
    for letter in string:
        if letter.isalnum():
            new_string += letter
        else:
            new_string += "_"
    out_tests.test_var_type(new_string, "new_string", str)
    return (new_string)

def write_filtered_vacancies_to_file(
        vacancies, filtered_path, filters):
    """
    Format and write filtered vacancies to file.
    File name == file creation timestamp.
    This function is for debugging purpose only.
    """
    timestamp = str(datetime.datetime.now())
    timestamp = replace_specials_to_underscore(timestamp)
    file_name = f"{filtered_path}/{timestamp}.txt".replace("//", "/")

    try:
        Path(file_name).parent.mkdir(parents=True, exist_ok=True)
    except PermissionError:
        print (f"I don't have permission to create {file_name}.\n\
Try to change {file_name} var value in `config.yaml` file or just solve this.")

    vacancies_counter = 1
    with open(file_name, "w", encoding="utf8") as f:
        f.write(f"FILTERS: {filters}\n\n")
        for vacancy in vacancies:
            f.write(f"#{vacancies_counter}\n")
            for key, value in vacancy.items():
                f.write (f"{key}: {value}\n")
            f.write(f"\n\n")
            vacancies_counter += 1
        f.write(f"FILTERS: {filters}\n\n")

    out_tests.test_is_file_exists(file_name)
    return ()

def format_msg_values(data):
    """
    1. Capitalize at 0 position and after [.?!] characters
    2. Replace None with ""
    type(data) in [str, int, float, None]
    """
    in_tests.test_var_type(data, "data", (str, int, float, type(None)))

    if isinstance(data, str):
        sentences = re.findall(r".*?(?:\.|\?|!|$)\s*", data)
        if sentences == []:
            formated_data = data.capitalize()
        else:
            formated_data = ""
            for sentence in sentences:
                formated_data += sentence.capitalize()
    elif isinstance(data, type(None)):
        formated_data = ""
    else:
        formated_data = data
    out_tests.test_var_type(formated_data, "formated_data", (str, int, float))
    return (formated_data)

def build_msg(vacancy, config):
    """
    Build html of one vacancy.
    """
    areas_table = deepcopy(config["tables"]["areas_table"])
    vacancies_table = deepcopy(config["tables"]["vacancies_table"])
    income_tax = deepcopy(config["income_tax"])
    in_tests.test_var_type(income_tax, "income_tax", (int, float))

    title = \
format_msg_values(vacancy[f"{vacancies_table}.name"])
    alternate_url = \
vacancy[f"{vacancies_table}.alternate_url"]
    salary_from = \
format_msg_values(vacancy[f"{vacancies_table}.salary_from"])
    salary_to = \
format_msg_values(vacancy[f"{vacancies_table}.salary_to"])
    salary_currency = \
format_msg_values(vacancy[f"{vacancies_table}.salary_currency"])
    is_before_tax = \
vacancy[f"{vacancies_table}.salary_gross"]
    requirement = \
format_msg_values(vacancy[f"{vacancies_table}.snippet_requirement"])
    responsibility = \
format_msg_values(vacancy[f"{vacancies_table}.snippet_responsibility"])
    schedule = \
format_msg_values(vacancy[f"{vacancies_table}.schedule_name"])
    working_time_intervals = \
format_msg_values(vacancy[f"{vacancies_table}.working_time_intervals_name"])
    working_time_modes = \
format_msg_values(vacancy[f"{vacancies_table}.working_time_modes_name"])
    city = \
format_msg_values(vacancy[f"{areas_table}.name"])
    address = \
format_msg_values(vacancy[f"{vacancies_table}.address_raw"])
    created = \
vacancy[f"{vacancies_table}.created_at"]

    if salary_from and salary_to and salary_from > salary_to:
        salary_from, salary_to = salary_to, salary_from
    if salary_currency:
        salary_currency = salary_currency.upper()
    if is_before_tax and salary_from:
        salary_from = int(salary_from - salary_from * income_tax)
    if is_before_tax and salary_to:
        salary_to = int(salary_to - salary_to * income_tax)
    if address:
        city = ""

    msg = f"<a href='{alternate_url}'>{title}</a>\n\
<em>{salary_from} - {salary_to} {salary_currency}</em>\n\n\
{responsibility}\n\n\
{requirement}\n\n\
{schedule}, {working_time_intervals}, {working_time_modes}\n\n\
{city}, {address}\n\n\
<em>Добавлено: {created}</em>"

    msg = msg.replace(", ,", ", ")
    msg = msg.replace("  ", " ")
    msg = msg.replace(" \n", "\n")
    msg = msg.replace(",\n", "\n")
    msg = msg.replace("\n,", "\n")
    msg = msg.replace("\n ", "\n")

    out_tests.test_var_type(msg, "message", str)
    out_tests.test_var_len_more_than(msg, "message", 149)
    return (msg)

def send_to_telegram(config):
    database = deepcopy(config["database"])
    areas_table = deepcopy(config["tables"]["areas_table"])
    vacancies_table = deepcopy(config["tables"]["vacancies_table"])
    chat_id = deepcopy(config["chat_id"])
    clean_path = deepcopy(config["clean_vacancies_file_path"])
    dirty_path = deepcopy(config["dirty_vacancies_file_path"])
    token = os.environ["hh_bot_token"]
    filters = deepcopy(config["filters"])
    kill_program_after = deepcopy(config["kill_program_after"])
    in_tests.test_database_name(database)
    in_tests.test_table_name(areas_table)
    in_tests.test_table_name(vacancies_table)
    in_tests.test_var_type(chat_id, "chat_id", int)
    in_tests.test_write_to_file_file_name(clean_path)
    in_tests.test_write_to_file_file_name(dirty_path)
    in_tests.test_var_type(token, "token", str)
    in_tests.test_var_len_more_than(token, "token", 0)
    in_tests.test_var_type(kill_program_after, "token", int)

    msg_columns = [
        f"{vacancies_table}.id",
        f"{vacancies_table}.is_sent",
        f"{vacancies_table}.name",
        f"{vacancies_table}.alternate_url",
        f"{vacancies_table}.salary_from",
        f"{vacancies_table}.salary_to",
        f"{vacancies_table}.salary_currency",
        f"{vacancies_table}.salary_gross",
        f"{vacancies_table}.snippet_responsibility",
        f"{vacancies_table}.snippet_requirement",
        f"{vacancies_table}.schedule_name",
        f"{vacancies_table}.working_time_intervals_name",
        f"{vacancies_table}.working_time_modes_name",
        f"{areas_table}.name",
        f"{vacancies_table}.address_raw",
        f"{vacancies_table}.created_at"
    ]

    msg_params = {
        "chat_id": chat_id,
        "parse_mode": "HTML"
        }

    query_filters = format_filters_to_query(
        filters, config)
    clean_vacancies, dirty_vacancies = filter_vacancies(
        config, msg_columns, query_filters)
    for vacancies, filtered_path in zip(
            [clean_vacancies, dirty_vacancies], [clean_path, dirty_path]):
        write_filtered_vacancies_to_file(
            vacancies, filtered_path, filters)

    print ("\n\nSending to Telegram... \n\
[You may recieve more vacancies than were got in current session\n\
if sending had failed during previous sessions.]\n")
    print (f"\nTotal messages to send: {len(clean_vacancies)}")
    print (f"Program will auto-terminate in {kill_program_after} seconds to \
avoid overlapping with scheduled starts.\n\
It is highly recommended to set schedule interval to be larger than \
`config.yaml > kill_program_after` one.\n")
    sent_counter = 0
    stop_time = datetime.datetime.now() + datetime.timedelta(
        seconds=kill_program_after)
    for clean_vacancy in clean_vacancies:
        if datetime.datetime.now() > stop_time:
            break
        vacancy_id = clean_vacancy[f"{vacancies_table}.id"]
        msg = build_msg(clean_vacancy, config)
        msg_params["text"] = msg
        while True:
            try:
                if datetime.datetime.now() > stop_time:
                    break
                response = requests.get(
                    f"https://api.telegram.org/bot{token}/sendMessage", \
                    params=msg_params)
                out_tests.test_is_status_code_200(response)
                set_is_sent_1(database, vacancies_table, vacancy_id)
                sent_counter += 1
                break
            except AssertionError:
                sleep_time = 60
                print (
        f"\n\nPhew, I was toooo fast. Need a rest for {sleep_time} seconds...")
                time.sleep(sleep_time)
                continue
    print (f"\n\nSent {sent_counter} vacancies.")
    print (f"{len(clean_vacancies)-sent_counter} unsent vacancies \
will be processed in next sessions.")
    return ()
